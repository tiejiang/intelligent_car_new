#include "Dynamic_Map.h"
#include "Dijkstra.h"
#include "LCD5110.h"

int vexs[15];//顶点信息
int vexnum = 10;
int arcnum = 13;//顶点数和边数
int p[MAX_VERTEX_NUM][MAX_VERTEX_NUM];//最短路径数组p
int D[MAX_VERTEX_NUM];//最短距离数组D
int pre_Node_Count = 0;
int angle_Array[10];	//装载路径规划后各个节点对应的角度值
//地图矩阵---邻接矩阵
//int arcs[6][6] = {
//					{1000,1000,10,1000,30,100},
//					{1000,1000,5,1000,1000,1000},
//					{1000,1000,1000,50,1000,1000},
//					{1000,1000,1000,1000,1000,10},
//					{1000,1000,1000,20,1000,60},
//					{1000,1000,1000,1000,1000,1000}
//					};
int arcs[10][10] = {
		{1000,1000,1,1000,1000,1000,1000,1000,1000,1000},
		{1000,1000,4,1000,6,1000,1000,1000,1000,1000},
		{1,4,1000,5,1000,20,1000,1000,1000,1000},
		{1000,1000,5,1000,1000,1000,2,1000,1000,1000},
		{1000,6,1000,1000,1000,3,1000,7,1000,1000},
		{1000,1000,20,1000,3,1000,6,1000,1000,4},
		{1000,1000,1000,2,1000,6,1000,1000,3,1000},
		{1000,1000,1000,1000,7,1000,1000,1000,1000,2},
		{1000,1000,1000,1000,1000,1000,3,1000,1000,8},
		{1000,1000,1000,1000,1000,4,1000,2,8,1000}
		};
//节点位置矩阵
//int node_Position_Matrix[6][6] = {
//					{1000,1000,30,1000,40,150},
//					{1000,1000,50,1000,1000,1000},
//					{1000,1000,1000,50,1000,1000},
//					{1000,1000,1000,1000,1000,10},
//					{1000,1000,1000,20,1000,60},
//					{1000,1000,1000,1000,1000,1000}
//					};
int node_Position_Matrix[10][10] = {								//只对用到了的节点对应角度进行修改
					{1000,1000,193,1000,1000,1000,1000,1000,1000,1000},
					{1000,1000,4,1000,193,1000,1000,1000,1000,1000},
					{1,135,1000,283,1000,20,1000,1000,1000,1000},
					{1000,1000,135,1000,1000,1000,193,1000,1000,1000},
					{1000,6,1000,1000,1000,283,1000,7,1000,1000},
					{1000,1000,20,1000,3,1000,6,1000,1000,193},
					{1000,1000,1000,2,1000,135,1000,1000,3,1000},
					{1000,1000,1000,1000,7,1000,1000,1000,1000,2},
					{1000,1000,1000,1000,1000,1000,3,1000,1000,8},
					{1000,1000,1000,1000,1000,4,1000,2,8,1000}
					};

//算法参数初始化以及算法调用
void plan_Route(int startNode){
	int i;	
	//确定顶点数、边数
//	vexnum = 10;
//	arcnum = 13;	
	//输入顶点
	for(i=0; i<vexnum; i++){
		vexs[i] = i;
	}	
	
	ShortestPath_DIJ(vexs, arcs, vexnum, arcnum, startNode, p, D);	
}
//将路径规划的节点与对应角度数据组合为新的矩阵
int is_path_prepare = 0;
void combine_Angle_Data(int vertex_num){
	int i;	
	
	for(i=0; i<vertex_num; i++){		
		if(p[vertex_num-1][i]>-1){
			pre_Node_Count++;				//记录整个任务完成要经过的节点总数
			if(p[vertex_num-1][i+1]>-1){
					//		LCD5110ShowNum(35, 3, p[5][i]);
					//		delay_ms(3000);
				//----核心，将p矩阵中对应两个节点作为node_Position_Matrix[行][列]的参数取出对应并角度赋给angle_Array数组对应位置
				//同时，node_Position_Matrix[][]和arcs[][]两个矩阵对应数据位置相同，这就是动态改变两个矩阵数据的联系和关键
				angle_Array[i] = node_Position_Matrix[p[vertex_num-1][i]][p[vertex_num-1][i+1]];
				is_path_prepare = 1;			//节点对应的角度数据准备完成
//							LCD5110ShowNum(35, i, angle_Array[i]); //---test
							
			}
//								LCD5110ShowNum(30, 5, pre_Node_Count); //---test
		}
	}
}			
//通过节点数据获得对应角度值
int get_Angle_Value(int actual_Node_Num){
	return angle_Array[actual_Node_Num];
}
//获取顶点数
int get_vexnum(){
	return vexnum;
}
//修改两个初始矩阵的对应节点数据
void change_Map(int node_num){
	int node_number = get_vexnum();			//取得地图的顶点数据
	node_Position_Matrix[p[node_number-1][node_num]][p[node_number-1][node_num+1]] = INFINITY;			//修改节点位置矩阵对应的角度值
	arcs[p[node_number-1][node_num]][p[node_number-1][node_num+1]] = INFINITY;											//修改地图矩阵对应的节点支路信息	
}

